<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <title>DNA Helix met Kubussen</title>
    <style>
        body { margin: 0; background: #000; }
        canvas { display: block; }
    </style>
</head>
<body>
<script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    // Scene
    const scene = new THREE.Scene();

    // Camera
    const camera = new THREE.PerspectiveCamera(
        75, window.innerWidth / window.innerHeight, 0.1, 1000
    );
    camera.position.set(0, 0, 100);
    camera.lookAt(0, 0, 0);

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Licht
    const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
    scene.add(ambientLight);

    const pointLight = new THREE.PointLight(0xffffff, 1);
    pointLight.position.set(20, 20, 20);
    scene.add(pointLight);

    // DNA parameters
    const cubes = [];
    const geometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
    const total = 60;       // aantal segmenten
    const radius = 6;       // straal van de helix
    const spacing = 2;      // afstand langs z-as

    for (let i = 0; i < total; i++) {
        // willekeurige kleuren per zijde
        const materials1 = Array.from({ length: 6 }, () =>
            new THREE.MeshStandardMaterial({
                color: new THREE.Color(Math.random(), Math.random(), Math.random())
            })
        );
        const materials2 = Array.from({ length: 6 }, () =>
            new THREE.MeshStandardMaterial({
                color: new THREE.Color(Math.random(), Math.random(), Math.random())
            })
        );

        // eerste streng
        const cube1 = new THREE.Mesh(geometry, materials1);
        const angle1 = i * 0.35;
        cube1.position.set(
            Math.cos(angle1) * radius,
            Math.sin(angle1) * radius,
            i * spacing
        );
        scene.add(cube1);
        cubes.push(cube1);

        // tweede streng (180Â° verschoven)
        const cube2 = new THREE.Mesh(geometry, materials2);
        const angle2 = angle1 + Math.PI;
        cube2.position.set(
            Math.cos(angle2) * radius,
            Math.sin(angle2) * radius,
            i * spacing
        );
        scene.add(cube2);
        cubes.push(cube2);

        // verbindingsstukje (basenpaar)
        const connectorGeometry = new THREE.BoxGeometry(0, 0, 0);
        const connectorMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
        const connector = new THREE.Mesh(connectorGeometry, connectorMaterial);
        connector.position.set(
            (cube1.position.x + cube2.position.x) / 2,
            (cube1.position.y + cube2.position.y) / 2,
            cube1.position.z
        );
        scene.add(connector);
        cubes.push(connector);
    }

    // Animatie
    function animate() {
        requestAnimationFrame(animate);

        // draai de hele helix langzaam
        scene.rotation.x += 0.01;


        // laat de kubussen zelf ook een beetje draaien
        cubes.forEach(c => {
            c.rotation.x += 0.08;
            c.rotation.y += 0.08;
        });

        renderer.render(scene, camera);
    }
    animate();

    // Responsief
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>